# 트랜잭션과 스프링 트랜잭션

## 0단계 - ACID

### 트랜잭션
- 데이터의 정합성을 보장하기 위해 고안된 방법
- 목적
  - 오류로부터 복구를 허용하고 데이터베이스를 일관성 있게 유지하는 안정적인 작업 단위를 제공
  - 동시에 접근하는 여러 프로그램 간에 격리를 제공

### ACID 기본 원칙
트랜잭션의 목적을 달성하기 위해 트랜잭션이 가져야 하는 속성
- 원자성(Atomicity)
  - 트랜잭션에 포함된 모든 작업이 모두 성공(Commit)하거나 실패(Rollback)해야 한다.
- 일관성(Consistency)
  - 트랜잭션을 실행한 전후에는 데이터의 일관성이 손상되지 않아야 한다.
  - 트랜잭션이 성공적으로 완료하면 언제나 동일한 데이터베이스 상태로 유지해야한다.
- 격리성(독립성)(Isolation)
  - 동시에 실행하는 여러 개의 트랜잭션이 서로 영향을 주지 않아야 한다.
- 영속성(지속성)(Durability)
  - 한번 커밋이 완료된 트랜잭션은 손상되지 않아야 한다.
  - 트랜잭션을 성공적으로 실행하면 그 결과가 항상 기록된다.

## 격리 레벨
트랜잭션이 얼마나 서로 독립적인지 나타내는 개념
- 왜 트랜잭션이 독립적이어야 할까?
  - 다양한 비정상(Anomaly) 상태, 현상을 방지하기 위해서다.
- 비정상적인 상태가 왜 나타나는가?
  - 동시에 여러 클라이언트가 데이터에 접근하고 수정하기 때문이다.
- 어떤 읽기 현상이 발생 할 수 있을까?
  - Dirty reads
    - 트랜잭션 A가 종료되지 못하고 롤백된다면, 트랜잭션 B는 무효가 된 데이터 값을 읽고 처리하면서 문제 
  - Non-repeatable reads
    - 같은 트랜잭션 내에서 select 문으로 a의 값을 두 번 조회했는데 (다른 트랜잭션이 그 사이 a 값을 커밋해서) 두 값이 다른 값이 나오는 데이터 불일치 문제 
  - Phantom reads
    - 새로운 데이터가 생기거나 없어져 있는 현상. 즉, 새로운 로우를 추가하는 것은 제한되지 않아 새로운 로우가 생기는 문제
- 격리 레벨은 어떤 것이 있을까?
  - Read Uncommitted
  - Read Committed
  - Repeatable Read
  - Serializable
- 격리 레벨에 따라 발생하는 현상

| 격리레벨 / 발생 현상     | Dirty reads | Non-repeatable reads | Phantom reads |
|------------------|-------------|----------------------|---------------|
 | Read Uncommitted | O           | O                    | O             |
 | Read Committed   | X           | O                    | O             |
 | Repeatable Read  | X           | X                    | O             |
 | Serializable     | X           | X                    | X             |

## Propagation
트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식

### 종류
- REQUIRED
  - 트랜잭션이 있으면 참여하고, 없으면 새로 시작
  - 두 메서드가 하나의 트랜잭션으로 실행되므로 어느 메서드에서 문제가 발생해도, 실행한 모든 데이터가 롤백
- REQUIRES_NEW
  - 항상 새로운 트랜잭션을 시작
  - 만약 REQUIRES_NEW가 아닌 다른 트랜잭션에서 오류가 터져도 새로운 트랜잭션이므로 롤백에 영향을 받지 않음
- SUPPORTS
  - 트랜잭션이 존재하는 경우 참여
  - 기존에 존재하는 트랜잭션이 없는 경우, 트랜잭션을 생성하지만 active는 false
- MANDATORY
  - 이미 트랜잭션이 존재하는 경우 참여하고 그렇지 않을 경우 예외 발생
- NOT_SUPPORTED
  - 트랜잭션을 사용하지 않게 한다.(보류)
  - 기존에 존재하는 트랜잭션이 없는 경우, 트랜잭션을 생성하지만 active는 false
- NESTED
  - JPA에서 지원하지 않는다. 변경감지를 통해서 업데이트문을 최대한 지연해서 발행하는 방식을 사용하기 때문에 중첩된 트랜잭션 경계를 설정할 수 없다.
  - 기존에 존재하는 트랜잭션이 없는 경우, active 트랜잭션을 생성
- Never
  - 트랜잭션이 존재하는 경우 예외를 발생
  - 기존에 존재하는 트랜잭션이 없는 경우, 트랜잭션을 생성하지만 active는 false
